import"./modules-5315f3b0.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))n(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&n(i)}).observe(document,{childList:!0,subtree:!0});function r(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerPolicy&&(s.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?s.credentials="include":o.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(o){if(o.ep)return;o.ep=!0;const s=r(o);fetch(o.href,s)}})();function j(t){if(!t)throw new Error("assertion error")}function x(t){if(typeof t!="object"||t===null)return!1;const e=Object.getPrototypeOf(t);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in t)&&!(Symbol.iterator in t)}function M(t){return b("Number")(t)}function q(t){return b("String")(t)}function C(t){return t===!0||t===!1}function S(t){return!v(t)}function J(t){return!!t}function v(t){return t==null}function K(t){j(S(t))}const b=(()=>{const{toString:t}=Object.prototype;return e=>{const r=e.toLowerCase(),n="[object ".concat(e,"]");return function(o){const s=typeof o;return s===r||!!o&&s==="object"&&t.call(o)===n}}})(),W=t=>(t==null?void 0:t.type)==="cs",V=t=>(t==null?void 0:t.type)==="cs"&&(t==null?void 0:t.error)!==void 0;class N{constructor(e="keyval-store",r="keyval"){this.storeName=r,this._dbp=new Promise((n,o)=>{const s=indexedDB.open(e,1);s.onerror=()=>o(s.error),s.onsuccess=()=>n(s.result),s.onupgradeneeded=()=>{s.result.createObjectStore(r)}})}_withIDBStore(e,r){return this._dbp.then(n=>new Promise((o,s)=>{const i=n.transaction(this.storeName,e);i.oncomplete=()=>o(),i.onabort=i.onerror=()=>s(i.error),r(i.objectStore(this.storeName))}))}}let u;function m(){return u||(u=new N),u}function I(t,e=m()){let r;return e._withIDBStore("readonly",n=>{r=n.get(t)}).then(()=>r.result)}function A(t,e,r=m()){return r._withIDBStore("readwrite",n=>{n.put(e,t)})}function B(t,e=m()){return e._withIDBStore("readwrite",r=>{r.delete(t)})}const L="ImmortalDB",T="key-value-pairs";class O{constructor(e=L,r=T){return this.store=new N(e,r),(async()=>{try{await this.store._dbp}catch(n){if(n.name==="SecurityError")return null;throw n}return this})()}async get(e){const r=await I(e,this.store);return typeof r=="string"?r:void 0}async set(e,r){await A(e,r,this.store)}async remove(e){await B(e,this.store)}}class R{constructor(e){return this.store=e,(async()=>this)()}async get(e){const r=this.store.getItem(e);return typeof r=="string"?r:void 0}async set(e,r){this.store.setItem(e,r)}async remove(e){this.store.removeItem(e)}}class E extends R{constructor(){super(window.localStorage)}}const l=console.log,f="_immortal|",D=typeof window<"u",p=[];try{D&&window.indexedDB&&p.push(O)}catch(t){}try{D&&window.localStorage&&p.push(E)}catch(t){}function g(t,e,r=null){return e in t?t[e]:r}function $(t){const e=new Map;let r=t.slice();for(const n of r){let o=0;for(const s of r)n===s&&(o+=1);o>0&&(e.set(n,o),r=r.filter(s=>s!==n))}return e}class P{constructor(e=p){this.stores=[],this.onReady=(async()=>{this.stores=(await Promise.all(e.map(async r=>{if(typeof r=="object")return r;try{return await new r}catch(n){return null}}))).filter(Boolean)})()}async get(e,r=null){await this.onReady;const n="".concat(f).concat(e),o=await Promise.all(this.stores.map(async c=>{try{return await c.get(n)}catch(a){l(a)}})),s=Array.from($(o).entries());s.sort((c,a)=>c[1]<=a[1]);let i;const[h,d]=g(s,0,[void 0,0]),[_,w]=g(s,1,[void 0,0]);return d>w||d===w&&h!==void 0?i=h:i=_,i!==void 0?(await this.set(e,i),i):(await this.remove(e),r)}async set(e,r){return await this.onReady,e="".concat(f).concat(e),await Promise.all(this.stores.map(async n=>{try{await n.set(e,r)}catch(o){l(o)}})),r}async remove(e){await this.onReady,e="".concat(f).concat(e),await Promise.all(this.stores.map(async r=>{try{await r.remove(e)}catch(n){l(n)}}))}}new P;const y=new P([E,O]),F={async set(t){await Promise.all(Object.entries(t).map(async e=>{const[r,n]=e;return await y.set(r,JSON.stringify(n))}))},async get(t){const e=await y.get(t).catch(r=>{throw console.log(r),new Error("Unable to get ".concat(JSON.stringify(t)," from storage"))});return e!=null?JSON.parse(e):void 0},async delete(t){await Promise.all(t.map(e=>y.remove(e)))},async load(t){const e=await Promise.all(t.map(r=>F.get(r).then(n=>[r,n])));return Object.fromEntries(e.filter(([,r])=>S(r)))}};export{v as a,K as b,J as c,x as d,j as e,M as f,C as g,W as h,S as i,V as j,q as k,F as w};
